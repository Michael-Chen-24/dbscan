---
title: "Density-based Cluster Validation"
output: html_notebook
---

```{r}
set.seed(2)
library("dbscan")
gen_square <- function(n, sd){
  x <- cbind(
    x = replicate(n, expr = runif(1, max = sd)) + rnorm(n, mean = c(0, 5, 5, 0), sd = sd),
    y = replicate(n, expr = runif(1, max = sd)) + rnorm(n, mean = c(0, 0, 5, 5), sd = sd)
  )
  true_clusters <- rep(1:4, time = n/4)
  return(list(x=x, cl = true_clusters))
}
```

Benchmarking 

```{r}
X <- gen_square(10000, sd = 1)
microbenchmark::microbenchmark({ dbscan::dbcv(X$x, cl = X$cl) }, times = 5L)

cl_list <- lapply(1:100, function(i) sample(1:as.integer(runif(1, min = 3, max = 100)), size = length(X$cl), replace = TRUE))

microbenchmark::microbenchmark({ dbscan::dbcv(X$x, cl = cl_list) }, times = 1L)
microbenchmark::microbenchmark({ 
  for (i in 1:100){  dbscan::dbcv(X$x, cl = cl_list[[i]]) }
}, times = 1L)

```

```{r}
X <- gen_square(10000, sd = 1)
microbenchmark::microbenchmark({ dbscan::dbcv(X$x, cl = X$cl) }, times = 1L)
```

```{r}
microbenchmark::microbenchmark({ all_pts_cd <- dbscan:::all_pts_core(x, cl_ids_idx, squared) }, times = 1L)

microbenchmark::microbenchmark({ 
  wut <- dbscan::kNN(X$x, k = 250, sort = FALSE) 
  all_cp_dist2 <- apply(wut$dist, 1, function(knn_dist){ (sum((1/knn_dist)^ncol(X$x))/(length(knn_dist)-1))^(-1/ncol(X$x)) })
}, times = 5L)
microbenchmark::microbenchmark({ dbscan::kNN(X$x, k = 250, sort = FALSE) }, times = 1L)
lapply(unique(X$cl), function(cl_id) which(X$cl == cl_id))
X$cl
```


## Test cases 

```{r}
## 1-dimensional case
x <- rnorm(1000)
n_class <- 6
class_prob <- runif(n_class)
cl <- sample(0:5, size = 1000, replace = TRUE, prob = class_prob/sum(class_prob <- runif(n_class)))
dbscan::dbcv(x, cl = cl)

## 2-dimensional case
x <- cbind(rnorm(1000), rnorm(1000))
n_class <- 6
class_prob <- runif(n_class)
cl <- sample(0:5, size = 1000, replace = TRUE, prob = class_prob/sum(class_prob <- runif(n_class)))
dbscan::dbcv(x, cl = cl)

## All 1 cluster case 
x <- rnorm(100)
cl <- rep(1L, 100)
dbscan::dbcv(x, cl = cl) ## should be warning 

## All noise case
x <- rnorm(100)
cl <- rep(0L, 100)
dbscan::dbcv(x, cl = cl) ## should be 0 

## All noise case
x <- rnorm(100)
cl <- 1:100
dbscan::dbcv(x, cl = cl) ## should be 0 

## All noise case
x <- rnorm(100)
cl <- rep(1:50, 2)
dbscan::dbcv(x, cl = cl) ## should be 0 


X <- gen_square(5000, sd = 1)
cl_ids_idx <- lapply(unique(X$cl), function(cid) which(X$cl == cid))

microbenchmark::microbenchmark({ 
test1 <- lapply(cl_ids_idx, function(cl_ids){
  clustertree:::testKNN_ref(qx = X$x[cl_ids,], rx = X$x, k = length(cl_ids), bucketSize = length(cl_ids)/2)
}) }, times = 5L)

all_pt_cd <- lapply(cl_ids_idx, function(cl_ids){
  res <- FNN::get.knnx(data = X$x, query = X$x[cl_ids,], k = length(cl_ids))
  apply((res$nn.dist^2)[, -1], 1, function(knn_dist){
    (sum((1/knn_dist[knn_dist != 0])^ncol(X$x))/(length(cl_ids) - 1))^(-1/ncol(X$x))
  })
})

cl_ids <- cl_ids_idx[[1]]
res <- FNN::get.knnx(data = X$x, query = X$x[cl_ids,], k = length(cl_ids))
(res$nn.dist^2)[1,]

all((res2$ndists - (res$nn.dist^2)[1,]) < sqrt(.Machine$double.eps))

res2 <- dbscan:::all_pts_core(X$x, cl_ids_idx, squared) 
range(res2$ndists)
range((res$nn.dist^2)[1,])


head((1/test)^ncol(X$x))
head(res2$ndists)

res2$ndists

test <- (res$nn.dist^2)[2,]
test[test == 0] <- (.Machine$double.eps*1e9)
(sum((1/test)^ncol(X$x))/(length(cl_ids)-1))^(-1/ncol(X$x))

sum(test)


microbenchmark::microbenchmark({ res2 <- dbscan:::all_pts_core(X$x, cl_ids_idx, squared) }, times = 5L)


mrd_graphs <- lapply(cl_ids_idx, function(idx){
  clustertree:::testClusterTree(X$x[idx,], k = length(idx), alpha = 1)
  # rel_idx <- match(idx, all_cl_ids)
  # mst <- prims(x_dist = dist_subset(cl_mrd, rel_idx), n = length(rel_idx))
  # matrix(mst[order(mst[, 3]),], ncol = 3) # return mst ordered by edge weight
})

peakRAM::peakRAM({ wut <- dbscan:::dbcv(x = X$x, cl = X$cl, squared = TRUE) })

```

```{r}
x1 <- "hi"
with(new.env(), expr = {
  testing1 <- paste0(x1, "wut")
  print(testing1)
})
```



```{r}
load("~/WaCS/ClusterTreePOIs/Data_sets/GeoLife 1.3 2012 GPS Trajectories (Beijing)/geolife_exemplar.rdata")
dist_geolife <- parallelDist::parDist(geolife_exemplar)
sl_geolife <- hclust(dist_geolife, method = "single")
sl_cl <- cutree(sl_geolife, k = 2)
dbcv(x = geolife_exemplar, cl = sl_cl, xdist = dist_geolife)

sl_cl <- cutree(sl_geolife, k = 3)
dbcv(x = geolife_exemplar, cl = sl_cl, xdist = dist_geolife)

```

```{r}
cppFunction('LogicalVector check_pow(NumericVector x, NumericVector y) {
  return(in(x, y));
}')
```



```{r}
sds <- c(0.1, 0.25, 0.5, 
         0.6,  0.7, 0.8, 
         1,    1.5,   2)
test <- lapply(sds, function(sd_i) gen_square(1000, sd_i))
layout(matrix(c(1:9), nrow = 3, ncol = 3, byrow = TRUE))
invisible(lapply(test, function(t1){
  plot(t1$x, col = t1$cl, pch = t1$cl, main = sprintf("DBCV: %.6s", dbscan::dbcv(x = t1$x, cl = t1$cl, squared = TRUE)))
}))
```

```{r}
idx <- 3
with(test[[idx]], {
  plot(x, col = cl, pch = cl, main = sprintf("DBCV: %.6s", dbscan::dbcv(x = x, cl = cl, squared = FALSE)))
})


```


```{r}
data("spiral")
plot(spiral[, 1:2], col = spiral[, 3], main = sprintf("DBCV: %0.4s", dbscan::dbcv(spiral[, 1:2], cl = spiral[, 3])))
```

```{r}
## Mimicking the test scenario done in the paper
minPts <- seq(4, 20, by = 2)
iris_dist <- dist(iris[, 1:4])
eps <- seq(min(iris_dist), max(iris_dist), length.out = 1000L)

params <- expand.grid(minPts=minPts, eps=eps)
cl_res <- mapply(function(mp_i, eps_i){
  dbscan::dbscan(x = iris[, 1:4], minPts = mp_i, eps = eps_i)
}, params[, 1], params[, 2], SIMPLIFY = FALSE)


ari_values <- sapply(cl_res, function(cl) mclust::adjustedRandIndex(x = cl$cluster, y = iris[,5]))
dbcv_values <- sapply(cl_res, function(cl) dbscan::dbcv(x = iris[,1:4], cl = cl$cluster, xdist = iris_dist))
ari_values[which.max(dbcv_values)]
plot(iris[, 1:4], col = cl_res[[which.max(dbcv_values)]]$cluster + 1)

```

